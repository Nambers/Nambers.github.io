[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: pwn.college-memory-errors-smashing-the-stack
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720
Original Translation: Eritque arcus
Original Editing: Eritque arcus
Original Timing: Eritque arcus
Synch Point: Eritque arcus

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: pwn.college-memory-errors-smashing-the-stack.mp4
Video File: pwn.college-memory-errors-smashing-the-stack.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.750000
Scroll Position: 146
Active Line: 155
Video Position: 29461

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Green,微软雅黑,32,&H002AEF7A,&H00000000,&H00164F05,&H00000000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,30,1
Style: 顶部黄字注释,微软雅黑,30,&H0000FFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0.3,8,10,10,18,1
Style: Green - 右中,微软雅黑,32,&H002AEF7A,&H00000000,&H00164F05,&H00000000,0,0,0,0,100,100,0,0,1,2,1,2,500,10,300,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.89,0:00:02.78,Green,,0,0,0,,Hello Hackers, welcome to pwn college.
Dialogue: 0,0:00:03.10,0:00:10.44,Green,,0,0,0,,我是 Yan, 这个视频我们会讨论一种很简单的内存错误\NI'm Yan, and in this video we going to be talking about memory error, specially a very simple type of memory error.
Dialogue: 0,0:00:11.13,0:00:13.74,顶部黄字注释,,0,0,0,,注: stack overflow 堆栈溢出
Dialogue: 0,0:00:11.13,0:00:13.74,Green,,0,0,0,,一种经典的 stack overflow\Nkind of classic stack overflow.
Dialogue: 0,0:00:14.30,0:00:17.87,Green,,0,0,0,,也就是 Smashing stack(践踏堆栈)\Nuh.. we will gonna about smashing, the stack.
Dialogue: 0,0:00:18.62,0:00:23.82,Green - 右中,,0,0,0,,让我们从一个简单的例子开始\NLet start with simple example, will be the example of the video, this will be the example of the video.
Dialogue: 0,0:00:24.24,0:00:33.04,Green - 右中,,0,0,0,,我们有左边的这一个程序, 他接从命令行参数(argv)接受一个输入\NLet's say we have a program, and the program takes input from the user on the command line, as command line argument.
Dialogue: 0,0:00:33.65,0:00:35.05,Green - 右中,,0,0,0,,那个命令行参数在这里\NThat right here, right?
Dialogue: 0,0:00:35.29,0:00:38.56,Green - 右中,,0,0,0,,然后它把这个输入传入"print_quoted"\NAnd it passes it to this "print_quoted" function.
Dialogue: 0,0:00:39.16,0:00:44.96,Green - 右中,,0,0,0,,然后"print_quoted"方法打印出一个被双引号括起来的输入\NAnd the "print_quoted" function, prints out, a quoted version of this string.
Dialogue: 0,0:00:45.53,0:00:47.26,Green - 右中,,0,0,0,,被双引号括起来的输入最终长什么样呢?\NWhat is the quoted version of the string look like?
Dialogue: 0,0:00:47.81,0:00:54.59,Green - 右中,,0,0,0,,我们有一个"quote"方法, 里面有一个输出缓冲区\NWe have this quoted function, that has an output buffer...
Dialogue: 0,0:00:54.77,0:01:04.58,Green - 右中,,0,0,0,,然后通过"sprintf"用被双引号包围的输入填充这个缓冲区\Nand it uses "sprintf" to fill the output buffer with a version of the string, that we passed it and surrounded by quotes, right.
Dialogue: 0,0:01:05.17,0:01:08.40,Green - 右中,,0,0,0,,其实这个程序有一些bug\Nuh... this program has a number of bugs in it.
Dialogue: 0,0:01:08.80,0:01:14.04,Green - 右中,,0,0,0,,在本视频中, 我们会讨论这个程序里出现的stack overflow问题\NAnd in this video, we're going to talk about the stack overflow that present in this program.
Dialogue: 0,0:01:14.48,0:01:19.16,Green - 右中,,0,0,0,,和 "sprintf" 里出现的 stack overflow\Nand the stack overflow occurs in this "sprintf".
Dialogue: 0,0:01:19.31,0:01:21.86,Green - 右中,,0,0,0,,"sprintf" 是不安全的\NThis "sprintf is unsafe.
Dialogue: 0,0:01:22.06,0:01:27.87,Green - 右中,,0,0,0,,主要是因为 "sprintf" 它没有任何办法去知道他接受的输出缓冲区有多大\NIt has no way of understanding how big the buffer is, and so, there are problems.
Dialogue: 0,0:01:28.32,0:01:31.79,Green - 右中,,0,0,0,,而且用户输入是不受限制的(比如大小), 让我们看看实际上会发生什么\Nand of course the user input is not limited. So, let's see what happens.
Dialogue: 0,0:01:32.38,0:01:40.09,Green - 右中,,0,0,0,,当一个恶意用户传入一个非常长的字符串给 "sprintf" 的第一个参数\NWhen a malicious user, passes in a very long argument into argue one, a very long string.
Dialogue: 0,0:01:40.81,0:01:47.80,Green - 右中,,0,0,0,,然后当 "sprintf" 运行的时候, 它会申请一个栈上的空间\NWhat happens, of course, when "sprintf" runs, it allocates some spaces on the stack...
Dialogue: 0,0:01:47.80,0:01:54.40,Green - 右中,,0,0,0,,来存放它需要的元数据和其他数据\Ncrates it's metadata, whatever local data that it needs to have.
Dialogue: 0,0:01:54.89,0:01:59.71,Green - 右中,,0,0,0,,然后当它被调用时, 这个返回地址被压入栈中\NAnd what it launches there is return address that is pushed, and return address says...
Dialogue: 0,0:02:00.12,0:02:04.70,Green - 右中,,0,0,0,,这个返回地址就是: 当程序从 "sprintf" 返回时, 从这里的第14行继续执行\Nwhen you return from "sprintf", go to this line 14th in the code.
Dialogue: 0,0:02:05.06,0:02:08.06,Green - 右中,,0,0,0,,当然在现实中我们是看二进制而不是现在看的源代码\NOf course, we are looking at source code, in reality it will be binary.
Dialogue: 0,0:02:08.69,0:02:17.96,Green - 右中,,0,0,0,,然后 "sprintf" 会写入一个双引号, 输入内容, 和另外一个双引号到栈里面\Nuh.. Then "sprintf" writes one quote, then the input, and then the another quote onto the stack...
Dialogue: 0,0:02:17.98,0:02:26.28,Green - 右中,,0,0,0,,更深入的说, 是进到了栈上 "quote" 方法栈帧中的输出缓冲区里\Nonto specially where it's output buffer was and the output buffer was in the stack frame of the quote function.
Dialogue: 0,0:02:26.91,0:02:38.75,Green - 右中,,0,0,0,,当这个输出缓冲区被 "sprintf" 填充时, 因为从命令行的输入没有大小限制, 我指如果有也是 65KB 大\NAnd when the output buffer is filled, because there is no limit on the size of a command line argument, or I mean, there is, but it's like 65 KB.
Dialogue: 0,0:02:42.97,0:02:48.73,Green - 右中,,0,0,0,,这整个16字节大的输出缓冲区会被完全填满\NThe entire output buffer, which was only 16 bytes long, is completely filled up.
Dialogue: 0,0:02:48.93,0:02:56.36,Green - 右中,,0,0,0,,然后你会注意到当整个缓冲区被传入 "sprintf" 时, 它只接收了个字符指针(没有大小信息)\NAnd if you notice, when you pass in this output into "sprintf", all that it takes, is a character pointer.
Dialogue: 0,0:02:56.60,0:02:59.26,Green - 右中,,0,0,0,,让我们看回命令行终端\NLet's take a look on the command line here.
Dialogue: 0,0:03:00.14,0:03:01.32,顶部黄字注释,,0,0,0,,注: 指打开 "sprintf" 的文档(Manual)
Dialogue: 0,0:03:00.14,0:03:01.32,Green,,0,0,0,,"man sprintf"
Dialogue: 0,0:03:03.10,0:03:05.90,Green,,0,0,0,,它只接收了个字符指针\N"sprintf" takes a character pointer.
Dialogue: 0,0:03:06.84,0:03:16.45,Green,,0,0,0,,对于这个传入的缓冲区指针, "sprintf" 没有任何办法去知道它的容量大小\NAnd for it's output buffer, it has no way of knowing the size of that character of buffer.
Dialogue: 0,0:03:18.09,0:03:22.83,Green - 右中,,0,0,0,,所以它没有办法去判断\NAnd so it has no choice, without any additional information provided to it.
Dialogue: 0,0:03:22.83,0:03:27.05,Green - 右中,,0,0,0,,当然, 对于一个设计良好的程序来说, 你可以在这里限制输入的大小\NOf course, in a well-formed program, you could put a size limit here.
Dialogue: 0,0:03:27.10,0:03:30.40,Green - 右中,,0,0,0,,或者你可以用更安全的替代方法 "snprintf"\NFor example, or you can use more safe function such as "snprintf".
Dialogue: 0,0:03:30.88,0:03:33.23,Green - 右中,,0,0,0,,"sprintf" 只能复制整个输入字符串到缓冲区当中\NIt has no choice but to copy the whole string.
Dialogue: 0,0:03:33.54,0:03:37.45,Green - 右中,,0,0,0,,显而易见的是, 当输入字符串长于缓冲区就会溢出. 那栈上跟在这个缓冲区后面的是什么?\NAnd of course, if the whole string is too long, it will overflow, and what is over here?
Dialogue: 0,0:03:37.82,0:03:44.10,Green - 右中,,0,0,0,,这里是它的返回地址, 我们之前说的当 "quote" 方法返回后...\NOver here, used to be the return address from quote, we said when quote return...
Dialogue: 0,0:03:45.21,0:03:52.21,Green - 右中,,0,0,0,,跳转到第9行继续运行, 在源代码中是 "print_quoted" 方法, 或者对应的任何指令\Ngo to line 9, in the source code in "print_quoted", or whatever binary instruction corresponded to that.
Dialogue: 0,0:03:52.78,0:04:01.30,Green - 右中,,0,0,0,,所以这就是可能会发生的事: 攻击者可以重写在缓冲区右边的全部东西, 包括返回地址\NSo happened, what happen is, the attacker input overwrites everything right over the buffer, and right over that return address.
Dialogue: 0,0:04:02.14,0:04:07.17,Green - 右中,,0,0,0,,然后当 "quote" 返回时会发生什么呢?\NThen when that return address, when the return form the function happens...
Dialogue: 0,0:04:07.69,0:04:10.27,顶部黄字注释,,0,0,0,,注: 后面会说怎么利用
Dialogue: 0,0:04:07.69,0:04:10.27,Green,,0,0,0,,这会导致一些严重的后果\Nthere are bad effects.
Dialogue: 0,0:04:10.85,0:04:15.29,Green,,0,0,0,,所以是哪里错了?\NSo, what went wrong here?
Dialogue: 0,0:04:15.64,0:04:20.28,Green,,0,0,0,,两个地方, 第一个是一种懒惰的编程习惯\NTwo things went wrong, one is a kind of lazy programming practice.
Dialogue: 0,0:04:20.78,0:04:24.93,Green,,0,0,0,,首先开发者很容易错误得使用 "sprintf"\NIt is very easy to screw up a call to "sprintf"...
Dialogue: 0,0:04:25.42,0:04:32.49,Green,,0,0,0,,这会导致stack overflow和其他不好的后果\Nand cause your stack to get overflowed, and bad things to happen.
Dialogue: 0,0:04:32.93,0:04:35.25,Green,,0,0,0,,这是一个小的问题\NThere is small subtle problem.
Dialogue: 0,0:04:35.55,0:04:45.60,Green,,0,0,0,,其次是在这个程序中, 固定空间大小的指针被传入可变大小的结构(指传入 "sprintf")\NThe more subtle problem is in this program, there were pointers being passed around to variable size data structures...
Dialogue: 0,0:04:46.12,0:04:49.02,Green,,0,0,0,,而且还是不带大小的传入\Nwithout the size also being passed around.
Dialogue: 0,0:04:49.13,0:04:58.96,Green,,0,0,0,,如果这里不用没有大小信息的字符指针\NIf instead of character array, instead of a character pointer of output being pass in along with no size information, if instead...
Dialogue: 0,0:05:00.21,0:05:05.28,Green,,0,0,0,,而是用 "snprintf" , 我们首先看一下它的文档\Nthe program use something like "snprintf". Let's take a look at our man pages again.
Dialogue: 0,0:05:05.28,0:05:13.71,Green,,0,0,0,,它接收缓冲区字符指针和大小作为参数\N"snprintf" takes the character buff pointer, and a size.
Dialogue: 0,0:05:13.88,0:05:18.01,Green,,0,0,0,,所以如果使用 "snprintf" , 就会传入一个大小来避免出现这个问题\NRight if this was used, and the size just passed in. This bug could been avoided.
Dialogue: 0,0:05:18.90,0:05:23.89,Green,,0,0,0,,不幸的是, 多数情况下 C 没有携带隐式元数据\NUnfortunately, often time in C because there is no implicit metadata to anything.
Dialogue: 0,0:05:24.36,0:05:34.24,Green,,0,0,0,,你可以看见很多内存错误导致的缓冲区溢出在现实生活中\Nyou see a lot of these sorts of memory errors leading to buffer overflow in real code.
Dialogue: 0,0:05:34.72,0:05:39.53,Green,,0,0,0,,接下来让我们看看能用这个内存损坏来做什么\NAlright, so let say what can you do with this memory corruption.
Dialogue: 0,0:05:39.85,0:05:45.90,Green,,0,0,0,,你可以用这个做很多事情, 首先你可以用它来重写一些无关紧要的内存\NRight, let's ask this reveal, well you can do a lot of stuff, you can of course overwrite memory that doesn't influence anything.
Dialogue: 0,0:05:46.08,0:05:49.93,Green,,0,0,0,,栈上有很多内容, 这不是我们想要的\NThere is plenty of memory padding on the stack et cetera. That boring.
Dialogue: 0,0:05:50.42,0:05:56.25,Green,,0,0,0,,这里有一些更值得关注的内存内容\NRight, but then there are a couple of more interesting things that you can do with a stack overflow.
Dialogue: 0,0:05:56.73,0:05:59.40,Green,,0,0,0,,首先\NLike we are discussing, you cloud...
Dialogue: 0,0:05:59.80,0:06:05.39,Green,,0,0,0,,你可以重写同一方法下的其他局部变量\Noverwrite some other memory on the stack, other local variable for example in that same function.
Dialogue: 0,0:06:05.82,0:06:13.29,Green,,0,0,0,,这通常会影响到一些数学计算, 或者条件调用之类的\NThat are used to influence some mathematical operation, some conditional jump et cetera.
Dialogue: 0,0:06:13.66,0:06:25.97,顶部黄字注释,,0,0,0,,注: 在简单的 CTF 题里, 当你调用了 win 方法就代表你完成了这题, 比如它会输出 flag 或者调用 "bin/sh" 之类的
Dialogue: 0,0:06:13.66,0:06:25.97,Green,,0,0,0,,你可能还记得 "win" 方法, 但是我们目前还没见过, 他在这个模块下的问题里出现\NYou may remember the win, well I guess you wouldn't have seen that yet, in the challenge problems for this module.
Dialogue: 0,0:06:26.17,0:06:31.40,Green,,0,0,0,,你以后会见到这类需要被重写的变量\NYou will see these sorts of variables that you can overwrite and influence.
Dialogue: 0,0:06:31.86,0:06:37.73,Green,,0,0,0,,其次你可以重写一些被用作读指针或者读指针的偏移量的内存\NYou can also overwrite some memory that used as a read pointer or an offset of a read pointer.
Dialogue: 0,0:06:38.01,0:06:42.50,Green,,0,0,0,,这样程序就会读到一些它不该读到的内存\NThat will allow you to focus the program to access some memory that wasn't support to.
Dialogue: 0,0:06:43.16,0:06:50.29,Green,,0,0,0,,类似的, 你也可以对写指针做相同的事, 这被称为内存重写漏洞\NYou could do the same for a write pointer, allowing for what is called an arbitrary write or a memory overwrite.
Dialogue: 0,0:06:51.20,0:06:56.05,Green,,0,0,0,,最后是一种类似的但是杀伤力更大的重写内容\Nvulnerability you can use something similar but even more brutal.
Dialogue: 0,0:06:56.37,0:07:03.32,Green,,0,0,0,,重写程序会在接下来用来控制程序流的代码指针\Nwhich is overwriting a code pointer, a pointer that the program will later use to transfer control flow.
Dialogue: 0,0:07:03.77,0:07:09.04,Green,,0,0,0,,比如返回地址, 我们可以在这个例子里看见返回地址的重写\NFor example, the return address that we saw being overwritten in the example.
Dialogue: 0,0:07:09.36,0:07:12.70,Green,,0,0,0,,这也被称为程序流劫持\NThis is called a control flow hijack.
Dialogue: 0,0:07:13.22,0:07:21.73,Green,,0,0,0,,对于这个的利用是非常强大的, 因为你控制了整个程序\NExploit and it is very very powerful type of exploit because you take control of the program.
Dialogue: 0,0:07:22.20,0:07:34.06,Green,,0,0,0,,类似的, 你可以做很多次这些重写\NTypically, of course you might be able to do multiple of this effects by either triggering the same bug multiple times or...
Dialogue: 0,0:07:36.10,0:07:40.62,Green,,0,0,0,,或者重写一些系列互相影响的内容\Nyou know, overwriting multiple different things that are used in sequences, for example.
Dialogue: 0,0:07:41.16,0:07:48.14,Green,,0,0,0,,但在本视频里, 我们会着重关注...\NBut of course, the ultimate power and what we will focus on and especial the later part of the homework...
Dialogue: 0,0:07:48.58,0:07:51.88,Green,,0,0,0,,返回指针(或者地址)重写\Nis return pointer overwriting.
Dialogue: 0,0:07:52.04,0:07:56.75,Green,,0,0,0,,通过缓冲区溢出去重写返回地址\NYou overflow a stack buffer to overwrite the return address.
Dialogue: 0,0:07:56.82,0:08:01.36,Green,,0,0,0,,虽然这在很多情况下里已经过时了\NAnd there also too complication and in many many cases this is now obsolete.
Dialogue: 0,0:08:01.45,0:08:06.17,Green,,0,0,0,,但是我们还是会在这个模块讲这个\NBut we will roll into that in this module.
Dialogue: 0,0:08:06.58,0:08:09.24,Green,,0,0,0,,你还可以做其他有趣的事情\NOther things you can do that are very interesting.
Dialogue: 0,0:08:09.64,0:08:18.26,Green,,0,0,0,,你不只可以用重写返回指针去调用其他方法, 你也可以去调用任何指令\NYou can jump not just to a different function in your return point or overwrite, you can jump into any instruction.
Dialogue: 0,0:08:19.04,0:08:24.00,Green,,0,0,0,,这是一种非常强大的能力\NThis is very powerful capability.
Dialogue: 0,0:08:24.44,0:08:33.31,Green,,0,0,0,,你其实可以改变功能, 我们会在下一模块深入的去讲这个和面向返回编程\NYou can actually change functionality, we will dive into this at extreme depth in next module actually and return oriented programming.
Dialogue: 0,0:08:33.70,0:08:46.84,Green,,0,0,0,,然后你也可以在不同指令之间跳转, 这是一种有趣的能力在 x86 和 amd64 平台下\NAnd you can jump between instructions as well, these also very interesting sort of capability especially on X86 and AMD64.
Dialogue: 0,0:08:47.53,0:08:51.64,Green,,0,0,0,,在下一模块会讲到对于这三个概念的利用\NReal explore these three concepts in next module.
Dialogue: 0,0:08:51.64,0:09:00.22,Green - 右中,,0,0,0,,现在让我们看回我们的例子然后考虑重写返回地址去调用其他方法\NFor now, let's look back at our example and consider overwriting the return address to point to some other functions.
Dialogue: 0,0:09:02.43,0:09:07.66,Green - 右中,,0,0,0,,特别是在这里, 我们进行了重写返回地址的攻击\NAnd specifically here we have our attack where we overwrite the return address.
Dialogue: 0,0:09:08.02,0:09:17.00,Green - 右中,,0,0,0,,我们可以重写返回地址去控制程序或者调用 win 方法或其他方法...\NWe could overwrite it with a return address that we control and specifically if there is, for example, a win function or whatever a function that...
Dialogue: 0,0:09:17.04,0:09:21.58,Green - 右中,,0,0,0,,来执行任意命令\Nexecute arbitrary command that is a very desirable function.
Dialogue: 0,0:09:21.93,0:09:29.62,Green - 右中,,0,0,0,,看回代码, 我们可以重写 "quote" 方法的返回地址\NTo jump into the code, we can overwrite the return address with the location of that function and then, when "quote" returns...
Dialogue: 0,0:09:30.09,0:09:34.77,Green - 右中,,0,0,0,,我们可以调用我们想调用的任意方法\NWe will execute the function that we want to execute.
Dialogue: 0,0:09:35.85,0:09:41.60,Green - 右中,,0,0,0,,让我们在控制台里看这个具体要怎么做\NLet's take a quick at the terminal how this actually works in practice actually.
Dialogue: 0,0:09:41.60,0:09:48.27,Green,,0,0,0,,首先我们在 binary-ninja 里打开, 我事先已经编译好了程序\NFirst let's look on binary-ninja, so, I compiled this program.
Dialogue: 0,0:09:48.40,0:10:00.04,Green,,0,0,0,,这是 main 方法, 它调用了 "print_quoted" 方法, 然后 "print_quoted" 方法又调用了 "quote" 方法, "quote" 方法最终调用了 "sprintf" 然后返回\NHere is main, which of course calls "print_quoted", "print_quoted" calls "quote", "quote" calls "sprintf" and then returns.
Dialogue: 0,0:10:00.44,0:10:05.95,Green,,0,0,0,,让我们看回控制台\NLet's jump to the terminal and we will...
Dialogue: 0,0:10:07.77,0:10:15.55,Green,,0,0,0,,打开 gdb, 这是一个已经分好窗口的 gdb, 你可以用 pwn college 里...\Ngdb on this so this is gdb was split mind and stuff you can of course set it up or use pwn college infrastructure which has...
Dialogue: 0,0:10:16.01,0:10:22.78,Green,,0,0,0,,已经有的指引来配置\Nthis available to you kind of pre-setup.
Dialogue: 0,0:10:23.84,0:10:38.56,Green,,0,0,0,,我们在 "quote" 方法设置一个断点, 然后我们输入一个正常输入\NSo let's break at the "quote" function, and then run with a normal input.
Dialogue: 0,0:10:38.78,0:10:40.54,Green,,0,0,0,,Sorry, my mind went blank.
Dialogue: 0,0:10:40.90,0:10:50.26,Green,,0,0,0,,所以现在我们在 "quote" 方法中断了, 让我们步进然后看看堆栈里有什么\NSo we broke at "quote", and you can see on stack here actually let's step through the stack setup.
Dialogue: 0,0:10:52.02,0:10:58.65,Green,,0,0,0,,好! 现在我们步进到想要的位置里, 然后我们看向...\NOk, now we should have the stack all setup, if we look at...
Dialogue: 0,0:11:00.01,0:11:10.91,顶部黄字注释,,0,0,0,,注: RSP 堆栈指针寄存器通常指向栈顶
Dialogue: 0,0:11:00.00,0:11:10.91,Green,,0,0,0,,RSP寄存器, 里面现在是空的, 或者说栈里还没内容, 这里应该被写入被双引号括起来的输入\NRSP we have but nothing on RSP yet, or nothing on our stack. This should be where we write quoted version of our input, which was...
Dialogue: 0,0:11:11.47,0:11:18.08,Green,,0,0,0,,如果我没记错的话, 是 "hello" 作为第一个程序输入, 所以...\Nif I remember correctly, "hello" as first argument. So if you go...
Dialogue: 0,0:11:19.36,0:11:30.93,Green,,0,0,0,,下一个问题, 现在我们执行 "sprintf", 格式化模板为 "\"%s\"", 输入是 "hello"\Nnext question alright, now we about to execute "sprintf" with a formatted string of quote %s quote and the argument "hello".
Dialogue: 0,0:11:31.92,0:11:37.30,Green,,0,0,0,,这就是我们的栈缓冲区了\NHere is our stack buffer, before.
Dialogue: 0,0:11:41.05,0:11:43.96,Green,,0,0,0,,发生什么事了\NWhat the heck.
Dialogue: 0,0:11:56.74,0:11:58.22,Green,,0,0,0,,这应该正确的\NThis should be correct.
Dialogue: 0,0:12:09.56,0:12:18.38,Green,,0,0,0,,可能它只是不在这个栈帧的顶部\NOh well, it just might be the top of the, so seemingly, it is at RDI.
Dialogue: 0,0:12:20.83,0:12:29.61,顶部黄字注释,,0,0,0,,注: 这里的 "hello" 就是在输出缓冲区里
Dialogue: 0,0:12:20.83,0:12:29.61,Green,,0,0,0,,所以这就是我们的 "hello", 它在 RSP+0x10 的地方, 可能是因为内存对齐\NSo here is our "hello", it is RSP out of 10, for some reasons, maybe they was padding or X10.
Dialogue: 0,0:12:29.68,0:12:43.84,Green,,0,0,0,,这就是我们的字符串了, 它已经被双引号括起来然后我们准备返回\NSo here is our string, "hello", quoted and nicely and if we look at, if we go to next instruction, we are about to return.
Dialogue: 0,0:12:46.31,0:12:57.04,顶部黄字注释,,0,0,0,,注: RSP(0xC28) - 缓冲区(0xC10) = 0x18
Dialogue: 0,0:12:46.31,0:12:57.04,Green,,0,0,0,,RSP 指向 0xC28 结尾的地址, 所以距离 "hello" 0x18 就是返回地址的地址\NHere is at C28, so hex 18 away from "hello" is the return address that we about to return to.
Dialogue: 0,0:12:57.94,0:13:08.25,Green,,0,0,0,,你可以在这里看 backtrace, 它接下来会返回到 "print_quoted" 方法, 然后继续运行\NYou can see this back-traces right here, so we're about go from "quote" to "print_quoted", and we're backing to "print_coded" and we can continue onward.
Dialogue: 0,0:13:08.35,0:13:11.91,Green,,0,0,0,,看起来什么东西坏掉了看不到输出内容\NIt looks like something is broken and we don't see the output.
Dialogue: 0,0:13:12.20,0:13:12.68,Green,,0,0,0,,没关系\NThat okay.
Dialogue: 0,0:13:13.20,0:13:20.29,Green,,0,0,0,,所以这就是这个程序被期望的运行流程\NAlright, so that basically how the program supposes to work, but let...
Dialogue: 0,0:13:20.78,0:13:28.40,Green,,0,0,0,,让我们看看我们自己作为一个恶意攻击者, 输入一个很长的字符串会发生什么\Nsee what happens when a malicious attacker, ourselves, instead sends a very long string.
Dialogue: 0,0:13:30.54,0:13:34.52,Green,,0,0,0,,现在让我们看回 "quote" 方法\NNow we're back at "quote", here we are.
Dialogue: 0,0:13:35.79,0:13:42.93,Green,,0,0,0,,一直步进直到 "sprintf" 被调用\NLet's just step through until we call "sprintf".
Dialogue: 0,0:13:43.76,0:13:54.03,Green,,0,0,0,,在这里, 我们将要用我们输出缓冲区指针调用 "sprintf"\N So here we go, we about to call "sprintf" with our buffer address...
Dialogue: 0,0:13:55.69,0:14:02.86,Green,,0,0,0,,以及一个 "%s" 的格式化模板参数和我们很长的输入字符串\N with the %s, a quoted %s, quote format and with our very large string now.
Dialogue: 0,0:14:03.52,0:14:05.37,Green,,0,0,0,,我们简单看一下\NSo let's take a look, real quick.
Dialogue: 0,0:14:05.55,0:14:08.57,Green,,0,0,0,,首先, 这里是输出缓冲区\NFirst, here is this buffer right? So...
Dialogue: 0,0:14:09.07,0:14:12.35,Green,,0,0,0,,这里是 RSP\Nif we see where RSP is, this is our RSP.
Dialogue: 0,0:14:17.00,0:14:26.00,Green,,0,0,0,,然后我们要写入到缓冲区, 我们要从 0xbb0 写到 0xbc0 也就是 0x10 的距离(缓冲区大小就是 16 字节)\NThis is where we are going to write stuff, so we will go from "bb0" to "bc0". So as before, we are 0x10 away.
Dialogue: 0,0:14:26.51,0:14:28.43,Green,,0,0,0,,然后哪里是返回地址?\NAnd where is our return address?
Dialogue: 0,0:14:28.97,0:14:43.85,顶部黄字注释,,0,0,0,,注: RBP 是栈帧指针, 通常指向栈帧起始位置
Dialogue: 0,0:14:28.97,0:14:43.84,Green,,0,0,0,,我们的返回地址在 RBP + 8 的位置, 如果你还记得我们对栈的讨论, RBP 指向栈的右边\NOur return address resides at RBP+8 so if you recall our discussion at stack, RBP points to right side of stack.
Dialogue: 0,0:14:44.35,0:14:56.66,Green,,0,0,0,,所以 RBP + 8 还要再往右一点\NThe kind of where right before the return address, so RBP+8 just one further right, that is the return value.
Dialogue: 0,0:14:56.88,0:15:00.46,Green,,0,0,0,,显然, 这个返回地址的内容指向 "print_quoted" 方法 + 28\NOf course points us to "print_quoted"+28 here.
Dialogue: 0,0:15:01.28,0:15:05.30,Green,,0,0,0,,然后我们就会返回到 "print_quoted" 方法\NWe will return back to "print_quoted".
Dialogue: 0,0:15:06.64,0:15:15.74,Green,,0,0,0,,如果我们继续步进, 我们会看见一些不同于正常输入的变化, 首当其冲的就是 backtrace 会变得一团糟\NIf we step over this, you about to see a couple of things change, the immediate thing is going be this back-trace will go completely nuts.
Dialogue: 0,0:15:16.73,0:15:23.86,Green,,0,0,0,,因为整个, 大部分的栈被我们用 'A' 重写了\NBecause the entire, well not entire but whole lots of stack was overwritten with 'A's...
Dialogue: 0,0:15:24.11,0:15:27.68,顶部黄字注释,,0,0,0,,注: ASCII: American Standard Code for Information Interchange
Dialogue: 0,0:15:24.11,0:15:27.68,Green,,0,0,0,,'A' 在 ASCII 里用 0x41 表示\Nwhich is in ASCII hex 41.
Dialogue: 0,0:15:27.80,0:15:31.52,Green,,0,0,0,,所以如果你现在看返回地址, 它里面全是 0x41\NSo if you look at the return address now, it's hex 41.
Dialogue: 0,0:15:32.26,0:15:39.39,Green,,0,0,0,,这是一个不好的情况, 因为如果我们继续执行\NThat's pretty bad news, because if we keep stepping where step to the stack cleanup...
Dialogue: 0,0:15:40.17,0:15:42.75,Green,,0,0,0,,执行到返回, 程序就崩溃了\Nwe're stepping through the return, and we crash.
Dialogue: 0,0:15:42.89,0:15:43.64,Green,,0,0,0,,为什么崩溃了?\NWhy do we crash?
Dialogue: 0,0:15:43.80,0:15:48.99,Green,,0,0,0,,因为程序尝试返回到返回指针指向的返回地址\NBecause we're trying to return, of course return pops, the return address of the stack, and goes there...
Dialogue: 0,0:15:49.38,0:15:53.49,顶部黄字注释,,0,0,0,,注: 所以就崩溃了, 因为返回地址不存在
Dialogue: 0,0:15:49.38,0:15:53.49,Green,,0,0,0,,但是地址里都是 'A' \Nand the return address is all 'A's, so that pretty bad news.
Dialogue: 0,0:15:54.08,0:15:59.18,Green,,0,0,0,,显而易见的, 对于全是 'A' 来说程序会崩溃, 但是如果我们有一个 "win" 方法呢\NObviously, for all 'A's, the program just crashes, but if we had a win function?
Dialogue: 0,0:15:59.90,0:16:01.88,Green,,0,0,0,,我们可以小心的构造一个输入\NWe could carefully craft our input.
Dialogue: 0,0:16:03.06,0:16:07.95,Green,,0,0,0,,然后使返回地址里就是 win 方法的地址, 而不是全都是 'A'\NSo, that instead of all 'A's, it contained the address of the win function.
Dialogue: 0,0:16:09.21,0:16:14.53,Green,,0,0,0,,好! 这就是一个很简单的 stack overflow 的例子\NAwesome, so this is the simplest stack overflow example.
Dialogue: 0,0:16:15.00,0:16:17.87,Green,,0,0,0,,它可能不是最简单的, 但是一个简单的例子\NOr not quite the simplest, but you know, a simple one.
Dialogue: 0,0:16:22.03,0:16:33.68,Green,,0,0,0,,{\pos(986,292)}字幕/轴/翻译: Eritque arcus\N来源: pwn.college\N在 {\b1}CC-BY-NC{\b0} 下发布\N2022.12
Dialogue: 0,0:16:22.02,0:16:27.44,Green,,0,0,0,,在这个模块剩下的部分里, 我们会继续讨论其他可能发生的内存错误\NIn the rest of the module, we are going to other memory errors that can occur.
Dialogue: 0,0:16:27.62,0:16:32.30,Green,,0,0,0,,和对应的补救手段\NAnd then the mitigation that are supposed to protect against their exploitation.
Dialogue: 0,0:16:33.02,0:16:33.46,Green,,0,0,0,,- EOF -\NThanks for watching.
Dialogue: 0,0:16:33.46,0:16:35.46,Green,,0,0,0,,
